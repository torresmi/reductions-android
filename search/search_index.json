{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Android app to find the latest video game deals.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Work in progress. This project allows me to experiment with new ideas and technology. My thoughts and ideas on topics are documented here.</p>"},{"location":"modularization/","title":"Modularization","text":""},{"location":"modularization/#benefits","title":"Benefits","text":"<ul> <li>Can result in faster compile times<ul> <li>Independent modules that are not changed or rely on changes can skip compiling again</li> </ul> </li> <li>Can enforce Architecture</li> <li>Can have pure Kotlin only modules and not bring in any Android complexity when its not needed</li> <li>Increased reusability</li> <li>More decoupled code</li> <li>Allows for fine-grained Gradle tasks on a subset of code</li> </ul>"},{"location":"modularization/#drawbacks","title":"Drawbacks","text":"<ul> <li>Overhead for creating new modules<ul> <li>Recommend using an IDE module template plugin</li> </ul> </li> <li>Need to be more careful with defining boundaries. Poorly defined boundaries can result in more issues<ul> <li>Can make code harder to find</li> <li>Can lead to cumbersome APIs</li> <li>Can lead to circular dependencies</li> <li>Might require re-defining the module and time is wasted on overhead</li> </ul> </li> <li>Dependency injection frameworks like Dagger 2 get more complicated</li> <li>Need to manage \"core\" code that is shared among N many modules</li> </ul>"},{"location":"modularization/#future-plans","title":"Future Plans","text":"<p>The current way things are broken up are by Clean Architecture layers. This helps enforce the architecture layer boundaries well, and also supports pure Kotlin modules over Android library modules. However, it really limits the benefits of modularization as the app scales.</p> <p>I would like to refactor this and try to split modules by architecture layer and feature layer. For example on the store feature: <code>stores-ui</code>, <code>stores-domain</code>, <code>stores-data</code>. I would also like for features to not depend on other features directly, as that can lead to longer recompiling from changes and circular dependencies. One way I would like to explore is the pattern of having \"api\" modules. These are just public interfaces that define contracts for other features to depend on. The root application provides the concrete implementation.</p> <p>Dagger setup will have to use component dependencies instead of sub components. Modules can define their own component and used when needed. The root application module will be the one managing these components.</p>"},{"location":"tooling/grade-benchmark/","title":"Gradle Benchmark","text":"<p>The fantastic gradle-profiler tool lets us benchmark different Gradle commands and fine-tune Gradle.</p>"},{"location":"tooling/grade-benchmark/#builds","title":"Builds","text":"<p>We often refer to \"build times\" as how long it takes for us to compile the project. However, this can vary a lot based on different factors.</p> <ul> <li>Clean build or incremental build?</li> <li>Gradle daemon enabled?<ul> <li>Gradle daemon warmed up?</li> <li>How warm is it?</li> </ul> </li> <li>Build cache enabled?</li> <li>Configuration cache enabled?</li> <li>Multi-module project?<ul> <li>What module or modules have changes?</li> <li>Are those changes impacting other modules?</li> </ul> </li> <li>Are we changing resource files that need to be processed?</li> <li>Are there other programs using computer resources as well?</li> </ul> <p>There are many things that can cause builds to vary drastically. So instead of thinking of a single concept of \"build times\", I like to group these up into build scenarios. Then run benchmarks on these scenarios to get a good idea of average times. This then allows tweaking and verifying through a more repeatable system.</p>"},{"location":"tooling/grade-benchmark/#running","title":"Running","text":"<p>To run the benchmark for builds we can execute the <code>benchmark_builds.sh</code> file. This sources scenarios from <code>build-scenarios.txt</code>. Try to avoid running other programs that can use up a lot of resources.</p>"}]}