apply plugin: 'jacoco'

jacoco {
    toolVersion '0.8.7'
}

project.afterEvaluate { project ->
    def isApp = project.plugins.hasPlugin("com.android.application")
    def isLibrary = project.plugins.hasPlugin("com.android.library")
    if (isApp || isLibrary) {
        setupAndroid()
    }
}


// Whether or not classes without source location should be instrumented
tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

tasks.withType(JacocoReport) {
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

def setupAndroid() {
    (android.hasProperty("applicationVariants") ? android."applicationVariants" : android."libraryVariants")
            .all { variant ->
                def variantName = variant.name
                def capVariantName = variantName.capitalize()
                def testTaskName = "test${capVariantName}UnitTest"
                tasks.create(name: "${variantName}Coverage", type: JacocoReport) {

                    group = "Reporting"
                    description = "Generate Jacoco coverage reports for the ${variantName} build."

                    reports {
                        html.enabled(true)
                        xml.enabled(true)
                    }

                    def fileFilter = [
                            // android
                            '**/R.class',
                            '**/R$*.class',
                            '**/BuildConfig.*',
                            '**/Manifest*.*',
                            '**/*Test*.*',
                            'android/**/*.*',
                            // kotlin
                            '**/*MapperImpl*.*',
                            '**/*$ViewInjector*.*',
                            '**/*$ViewBinder*.*',
                            '**/BuildConfig.*',
                            '**/*Component*.*',
                            '**/*BR*.*',
                            '**/Manifest*.*',
                            '**/*$Lambda$*.*',
                            '**/*Companion*.*',
                            '**/*Module*.*',
                            '**/*Dagger*.*',
                            '**/*Hilt*.*',
                            '**/*MembersInjector*.*',
                            '**/*_MembersInjector.class',
                            '**/*_Factory*.*',
                            '**/*_Provide*Factory*.*',
                            '**/*Extensions*.*',
                            // sealed and data classes
                            '**/*$Result.*',
                            '**/*$Result$*.*',
                            // adapters generated by moshi
                            '**/*JsonAdapter.*',
                            '**/coil/*',
                    ]

                    def jClasses = "${project.buildDir}/intermediates/javac/${variantName}/classes"
                    def kClasses = "${project.buildDir}/tmp/kotlin-classes/${variantName}"
                    def javaClasses = fileTree(dir: jClasses, excludes: fileFilter)

                    def kotlinClasses = fileTree(dir: kClasses, excludes: fileFilter)

                    classDirectories.from = files([javaClasses, kotlinClasses])
                    def sourceDirs = [
                            "${project.projectDir}/src/main/java",
                            "${project.projectDir}/src/main/kotlin",
                            "${project.projectDir}/src/${variantName}/java",
                            "${project.projectDir}/src/${variantName}/kotlin"
                    ]

                    sourceDirectories.from = files(sourceDirs)

                    executionData.from = files([
                            "${project.buildDir}/jacoco/${testTaskName}.exec",
                            "${project.buildDir}/outputs/unit_test_code_coverage/${variantName}UnitTest/${testTaskName}.exec"
                    ])
                }
            }

    tasks.register("coverAllVariants") {
        dependsOn(provider {
            tasks.findAll { task -> task.name.endsWith("Coverage") }
        })
    }
}
