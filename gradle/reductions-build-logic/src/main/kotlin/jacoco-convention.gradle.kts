import com.android.build.api.variant.ApplicationAndroidComponentsExtension
import com.android.build.api.variant.LibraryAndroidComponentsExtension
import org.gradle.configurationcache.extensions.capitalized

plugins {
    id("jacoco")
}

val fileFilters = setOf(
    // android
    "**/R.class",
    "**/R$*.class",
    "**/BuildConfig.*",
    "**/Manifest*.*",
    "**/*Test*.*",
    "android/**/*.*",
    // kotlin
    "**/*MapperImpl*.*",
    "**/*\$ViewInjector*.*",
    "**/*\$ViewBinder*.*",
    "**/BuildConfig.*",
    "**/*Component*.*",
    "**/*BR*.*",
    "**/Manifest*.*",
    "**/*\$Lambda$*.*",
    "**/*Companion*.*",
    "**/*Module*.*",
    "**/*Dagger*.*",
    "**/*Hilt*.*",
    "**/*MembersInjector*.*",
    "**/*_MembersInjector.class",
    "**/*_Factory*.*",
    "**/*_Provide*Factory*.*",
    "**/*Extensions*.*",
    // sealed and data classes
    "**/*$Result.*",
    "**/*$Result$*.*",
    // adapters generated by moshi
    "**/*JsonAdapter.*",
    "**/coil/*",
)

configure<JacocoPluginExtension> {
    toolVersion = "0.8.7"
}

// Whether or not classes without source location should be instrumented
tasks.withType(Test::class).configureEach {
    configure<JacocoTaskExtension> {
        isIncludeNoLocationClasses = false
        exclude("jdk.internal.*")
    }
}

tasks.withType(JacocoReport::class).configureEach {
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

extensions.findByType(ApplicationAndroidComponentsExtension::class)?.apply {
    onVariants { createAndroidTasks(it.name) }
    createAllVariantsTask()
}

extensions.findByType(LibraryAndroidComponentsExtension::class)?.apply {
    onVariants { createAndroidTasks(it.name) }
    createAllVariantsTask()
}

fun createAndroidTasks(variantName: String) {
    val capVariantName = variantName.capitalized()
    val testTaskName = "test${capVariantName}UnitTest"

    tasks.create("${variantName}Coverage", JacocoReport::class) {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for the $variantName build"

        reports {
            html.required.set(true)
            xml.required.set(true)
        }

        val buildDir = project.buildDir

        val jClasses = "$buildDir/intermediates/javac/$variantName/classes"
        val kClasses = "$buildDir/tmp/kotlin-classes/$variantName"

        val javaClasses = fileTree(jClasses) {
            exclude(fileFilters)
        }
        val kotlinClasses = fileTree(kClasses) {
            exclude(fileFilters)
        }

        classDirectories.from(javaClasses, kotlinClasses)

        val projectDir = project.projectDir
        val sourceDirs = setOf(
            "$projectDir/src/main/java",
            "$projectDir/src/main/kotlin",
            "$projectDir/src/$variantName/java",
            "$projectDir/src/$variantName/kotlin",
        )

        sourceDirectories.from(files(sourceDirs))

        executionData.from(
            files(
                "$buildDir/jacoco/$testTaskName.exec",
                "$buildDir/outputs/unit_test_code_coverage/${variantName}UnitTest/$testTaskName.exec",
            ),
        )
    }.dependsOn(testTaskName)
}

fun createAllVariantsTask() {
    tasks.register("coverAllVariants") {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for all variant builds"

        dependsOn(
            provider {
                tasks.find { task -> task.name.endsWith("Coverage") }
            },
        )
    }
}
